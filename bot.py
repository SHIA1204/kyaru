import os
import shutil
from os import system

import discord
import asyncio
import os.path
import linecache
import datetime

import urllib

import requests
from bs4 import BeautifulSoup

from discord.utils import get
from discord.ext import commands


from discord.ext.commands import CommandNotFound
import logging
import itertools
import sys
import traceback
import random
import itertools
import math
from async_timeout import timeout
from functools import partial
import functools
from youtube_dl import YoutubeDL
import youtube_dl
from io import StringIO
import time
import urllib.request
from gtts import gTTS

from urllib.request import URLError
from urllib.request import HTTPError
from urllib.request import urlopen
from urllib.request import Request, urlopen
from urllib.parse import quote
import re
import warnings
import unicodedata
import json

##################### Î°úÍπÖ ###########################
log_stream = StringIO()    
logging.basicConfig(stream=log_stream, level=logging.WARNING)

#ilsanglog = logging.getLogger('discord')
#ilsanglog.setLevel(level = logging.WARNING)
#handler = logging.StreamHandler()
#handler.setFormatter(logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s'))
#ilsanglog.addHandler(handler)
#####################################################

def init():
	global command

	command = []
	fc = []

	command_inidata = open('command.ini', 'r', encoding = 'utf-8')
	command_inputData = command_inidata.readlines()

	############## ÎÆ§ÏßÅÎ¥á Î™ÖÎ†πÏñ¥ Î¶¨Ïä§Ìä∏ #####################
	for i in range(len(command_inputData)):
		tmp_command = command_inputData[i][12:].rstrip('\n')
		fc = tmp_command.split(', ')
		command.append(fc)
		fc = []

	del command[0]

	command_inidata.close()

	#print (command)

init()

#mp3 ÌååÏùº ÏÉùÏÑ±Ìï®Ïàò(gTTS Ïù¥Ïö©, ÎÇ®ÏÑ±Î™©ÏÜåÎ¶¨)
async def MakeSound(saveSTR, filename):
	
	tts = gTTS(saveSTR, lang = 'ko')
	tts.save('./' + filename + '.wav')
	'''
	try:
		encText = urllib.parse.quote(saveSTR)
		urllib.request.urlretrieve("https://clova.ai/proxy/voice/api/tts?text=" + encText + "%0A&voicefont=1&format=wav",filename + '.wav')
	except Exception as e:
		print (e)
		tts = gTTS(saveSTR, lang = 'ko')
		tts.save('./' + filename + '.wav')
		pass
	'''
#mp3 ÌååÏùº Ïû¨ÏÉùÌï®Ïàò	
async def PlaySound(voiceclient, filename):
	source = discord.FFmpegPCMAudio(filename)
	try:
		voiceclient.play(source)
	except discord.errors.ClientException:
		while voiceclient.is_playing():
			await asyncio.sleep(1)
	while voiceclient.is_playing():
		await asyncio.sleep(1)
	voiceclient.stop()
	source.cleanup()

# Silence useless bug reports messages
youtube_dl.utils.bug_reports_message = lambda: ''


class VoiceError(Exception):
	pass


class YTDLError(Exception):
	pass


class YTDLSource(discord.PCMVolumeTransformer):
	YTDL_OPTIONS = {
		'format': 'bestaudio/best',
		'extractaudio': True,
		'audioformat': 'mp3',
		'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
		'restrictfilenames': True,
		'noplaylist': False,
		'nocheckcertificate': True,
		'ignoreerrors': False,
		'logtostderr': False,
		'quiet': True,
		'no_warnings': True,
		'default_search': 'auto',
		'source_address': '0.0.0.0',
		'force-ipv4' : True,
    		'-4': True
	}

	FFMPEG_OPTIONS = {
		'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
		'options': '-vn',
	}

	ytdl = youtube_dl.YoutubeDL(YTDL_OPTIONS)

	def __init__(self, ctx: commands.Context, source: discord.FFmpegPCMAudio, *, data: dict, volume: float = 0.5):
		super().__init__(source, volume)
		self.requester = ctx.author
		self.channel = ctx.channel
		self.data = data

		self.uploader = data.get('uploader')
		self.uploader_url = data.get('uploader_url')
		date = data.get('upload_date')
		self.upload_date = date[6:8] + '.' + date[4:6] + '.' + date[0:4]
		self.title = data.get('title')
		self.thumbnail = data.get('thumbnail')
		self.description = data.get('description')
		self.duration = self.parse_duration(int(data.get('duration')))
		self.tags = data.get('tags')
		self.url = data.get('webpage_url')
		self.views = data.get('view_count')
		self.likes = data.get('like_count')
		self.dislikes = data.get('dislike_count')
		self.stream_url = data.get('url')

	def __str__(self):
		return '**{0.title}** by **{0.uploader}**'.format(self)

	@classmethod
	async def create_source(cls, bot, ctx: commands.Context, search: str, *, loop: asyncio.BaseEventLoop = None):
		loop = loop or asyncio.get_event_loop()

		if "http" not in search:
			partial = functools.partial(cls.ytdl.extract_info, f"ytsearch5:{search}", download=False, process=False)

			data = await loop.run_in_executor(None, partial)

			if data is None:
				raise YTDLError('Couldn\'t find anything that matches `{}`'.format(search))

			emoji_list : list = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "4Ô∏è‚É£", "5Ô∏è‚É£", "üö´"]
			song_list_str : str = ""
			cnt : int = 0
			song_index : int = 0

			for data_info in data["entries"]:
				cnt += 1
				if 'title' not in data_info:
					data_info['title'] = f"{search} - Ï†úÎ™© Ï†ïÎ≥¥ ÏóÜÏùå"
				song_list_str += f"`{cnt}.` [**{data_info['title']}**](https://www.youtube.com/watch?v={data_info['url']})\n"

			embed = discord.Embed(description= song_list_str)
			embed.set_footer(text=f"10Ï¥à ÏïàÏóê ÎØ∏ÏÑ†ÌÉùÏãú Ï∑®ÏÜåÎê©ÎãàÎã§.")

			song_list_message = await ctx.send(embed = embed)

			for emoji in emoji_list:
				await song_list_message.add_reaction(emoji)

			def reaction_check(reaction, user):
				return (reaction.message.id == song_list_message.id) and (user.id == ctx.author.id) and (str(reaction) in emoji_list)
			try:
				reaction, user = await bot.wait_for('reaction_add', check = reaction_check, timeout = 10)
			except asyncio.TimeoutError:
				reaction = "üö´"

			for emoji in emoji_list:
				await song_list_message.remove_reaction(emoji, bot.user)

			await song_list_message.delete(delay = 10)
			
			if str(reaction) == "1Ô∏è‚É£":
				song_index = 0
			elif str(reaction) == "2Ô∏è‚É£":
				song_index = 1
			elif str(reaction) == "3Ô∏è‚É£":
				song_index = 2
			elif str(reaction) == "4Ô∏è‚É£":
				song_index = 3
			elif str(reaction) == "5Ô∏è‚É£":
				song_index = 4
			else:
				return False
			
			result_url = f"https://www.youtube.com/watch?v={data['entries'][song_index]['url']}"
		else:
			result_url = search

		webpage_url = result_url
		partial = functools.partial(cls.ytdl.extract_info, webpage_url, download=False)
		processed_info = await loop.run_in_executor(None, partial)
		if processed_info is None:
			raise YTDLError('Couldn\'t fetch `{}`'.format(webpage_url))
		
		if 'entries' not in processed_info:
			info = processed_info
		else:
			info = None
			while info is None:
				try:
					info = processed_info['entries'].pop(0)
				except IndexError:
					raise YTDLError('Couldn\'t retrieve any matches for `{}`'.format(webpage_url))

		return cls(ctx, discord.FFmpegPCMAudio(info['url'], **cls.FFMPEG_OPTIONS), data=info)

	@staticmethod
	def parse_duration(duration: int):
		return time.strftime('%H:%M:%S', time.gmtime(duration))


class Song:
	__slots__ = ('source', 'requester')

	def __init__(self, source: YTDLSource):
		self.source = source
		self.requester = source.requester

	def create_embed(self):
		embed = (discord.Embed(title='Now playing',
							description='**```fix\n{0.source.title}\n```**'.format(self),
							color=discord.Color.blurple())
				.add_field(name='Duration', value=self.source.duration)
				.add_field(name='Requested by', value=self.requester.mention)
				.add_field(name='Uploader', value='[{0.source.uploader}]({0.source.uploader_url})'.format(self))
				.add_field(name='URL', value='[Click]({0.source.url})'.format(self))
				.set_thumbnail(url=self.source.thumbnail))

		return embed


class SongQueue(asyncio.Queue):
	def __getitem__(self, item):
		if isinstance(item, slice):
			return list(itertools.islice(self._queue, item.start, item.stop, item.step))
		else:
			return self._queue[item]

	def __iter__(self):
		return self._queue.__iter__()

	def __len__(self):
		return self.qsize()

	def clear(self):
		self._queue.clear()

	def shuffle(self):
		random.shuffle(self._queue)

	def select(self, index : int, loop : bool = False):
		for i in range(index-1):
			if not loop:
				del self._queue[0]
			else:
				self._queue.append(self._queue[0])
				del self._queue[0]

	def remove(self, index: int):
		del self._queue[index]


class VoiceState:
	def __init__(self, bot: commands.Bot, ctx: commands.Context):
		self.bot = bot
		self._ctx = ctx
		self._cog = ctx.cog

		self.current = None
		self.voice = None
		self.next = asyncio.Event()
		self.songs = SongQueue()

		self._loop = False
		self._volume = 0.5
		self.skip_votes = set()

		self.audio_player = bot.loop.create_task(self.audio_player_task())

	def __del__(self):
		self.audio_player.cancel()

	@property
	def loop(self):
		return self._loop

	@loop.setter
	def loop(self, value: bool):
		self._loop = value

	@property
	def volume(self):
		return self._volume

	@volume.setter
	def volume(self, value: float):
		self._volume = value

	@property
	def is_playing(self):
		return self.voice and self.current

	async def audio_player_task(self):
		while True:
			self.next.clear()

			if self.loop and self.current is not None:
				source1 = await YTDLSource.create_source(self.bot, self._ctx, self.current.source.url, loop=self.bot.loop)
				song1 = Song(source1)
				await self.songs.put(song1)
			else:
				pass

			try:
				async with timeout(180):  # 3 minutes
					self.current = await self.songs.get()
			except asyncio.TimeoutError:
				self.bot.loop.create_task(self.stop())
				return

			self.current.source.volume = self._volume
			self.voice.play(self.current.source, after=self.play_next_song)
			play_info_msg = await self.current.source.channel.send(embed=self.current.create_embed())
#			await play_info_msg.delete(delay = 20)

			await self.next.wait()

	def play_next_song(self, error=None):
		if error:
			raise VoiceError(str(error))

		self.next.set()

	def skip(self):
		self.skip_votes.clear()

		if self.is_playing:
			self.voice.stop()

	async def stop(self):
		self.songs.clear()

		if self.voice:
			await self.voice.disconnect()
			self.voice = None

		self.bot.loop.create_task(self._cog.cleanup(self._ctx))

class Music(commands.Cog):
	def __init__(self, bot: commands.Bot):
		self.bot = bot
		self.voice_states = {}

	def get_voice_state(self, ctx: commands.Context):
		state = self.voice_states.get(ctx.guild.id)
		if not state:
			state = VoiceState(self.bot, ctx)
			self.voice_states[ctx.guild.id] = state

		return state

	def cog_unload(self):
		for state in self.voice_states.values():
			self.bot.loop.create_task(state.stop())

	def cog_check(self, ctx: commands.Context):
		if not ctx.guild:
			raise commands.NoPrivateMessage('This command can\'t be used in DM channels.')

		return True

	async def cog_before_invoke(self, ctx: commands.Context):
		ctx.voice_state = self.get_voice_state(ctx)

	async def cog_command_error(self, ctx: commands.Context, error: commands.CommandError):
		await ctx.send('ÏóêÎü¨ : {}'.format(str(error)))
	'''
	@commands.command(name='join', invoke_without_subcommand=True)
	async def _join(self, ctx: commands.Context):
		destination = ctx.author.voice.channel
		if ctx.voice_state.voice:
			await ctx.voice_state.voice.move_to(destination)
			return
		ctx.voice_state.voice = await destination.connect()
	'''
	async def cleanup(self, ctx: commands.Context):
		del self.voice_states[ctx.guild.id]

	@commands.command(name=command[0][0], aliases=command[0][1:]) #ÏùåÏÑ± Ï±ÑÎÑê ÏûÖÏû•
	#@commands.has_permissions(manage_guild=True)
	async def _summon(self, ctx: commands.Context, *, channel: discord.VoiceChannel = None):
		channel = ctx.message.author.voice.channel
		if not channel and not ctx.author.voice:
			raise VoiceError(':no_entry_sign: ÌòÑÏû¨ Ï†ëÏÜçÏ§ëÏù∏ ÏùåÏïÖÏ±ÑÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.')

		destination = channel or ctx.author.voice.channel
		if ctx.voice_state.voice:
			await ctx.voice_state.voice.move_to(destination)
			return

		ctx.voice_state.voice = await destination.connect()

	@commands.command(name=command[1][0], aliases=command[1][1:]) #ÏùåÏÑ± Ï±ÑÎÑê Ìá¥Ïû•
	#@commands.has_permissions(manage_guild=True)
	async def _leave(self, ctx: commands.Context):
		if not ctx.voice_state.voice:
			return await ctx.send(embed=discord.Embed(title=":no_entry_sign: ÌòÑÏû¨ Ï†ëÏÜçÏ§ëÏù∏ ÏùåÏïÖÏ±ÑÎÑêÏù¥ ÏóÜÏäµÎãàÎã§.",colour = 0x2EFEF7))

		await ctx.voice_state.stop()
		del self.voice_states[ctx.guild.id]

	@commands.command(name=command[8][0], aliases=command[8][1:]) #Î≥ºÎ•® Ï°∞Ï†à
	async def _volume(self, ctx: commands.Context, *, volume: int):
		vc = ctx.voice_client

		if not ctx.voice_state.is_playing:
			return await ctx.send(embed=discord.Embed(title=":mute: ÌòÑÏû¨ Ïû¨ÏÉùÏ§ëÏù∏ ÏùåÏïÖÏù¥ ÏóÜÏäµÎãàÎã§.",colour = 0x2EFEF7))

		if not 0 < volume < 101:
			return await ctx.send(embed=discord.Embed(title=":no_entry_sign: Î≥ºÎ•®ÏùÄ 1 ~ 100 ÏÇ¨Ïù¥Î°ú ÏûÖÎ†• Ìï¥Ï£ºÏÑ∏Ïöî.",colour = 0x2EFEF7))

		if vc.source:
			vc.source.volume = volume / 100

		ctx.voice_state.volume = volume / 100
		await ctx.send(embed=discord.Embed(title=f":loud_sound: Î≥ºÎ•®ÏùÑ {volume}%Î°ú Ï°∞Ï†ïÌïòÏòÄÏäµÎãàÎã§.",colour = 0x2EFEF7))

	@commands.command(name=command[7][0], aliases=command[7][1:]) #ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ Î™©Î°ù
	async def _now(self, ctx: commands.Context):
		await ctx.send(embed=ctx.voice_state.current.create_embed())

	@commands.command(name=command[3][0], aliases=command[3][1:]) #ÏùåÏïÖ ÏùºÏãú Ï†ïÏßÄ
	#@commands.has_permissions(manage_guild=True)
	async def _pause(self, ctx: commands.Context):
		if ctx.voice_state.is_playing and ctx.voice_state.voice.is_playing():
			ctx.voice_state.voice.pause()
			await ctx.message.add_reaction('‚è∏')

	@commands.command(name=command[4][0], aliases=command[4][1:]) #ÏùåÏïÖ Îã§Ïãú Ïû¨ÏÉù
	#@commands.has_permissions(manage_guild=True)
	async def _resume(self, ctx: commands.Context):
		if ctx.voice_state.is_playing and ctx.voice_state.voice.is_paused():
			ctx.voice_state.voice.resume()
			await ctx.message.add_reaction('‚èØ')

	@commands.command(name=command[9][0], aliases=command[9][1:]) #ÏùåÏïÖ Ï†ïÏßÄ
	#@commands.has_permissions(manage_guild=True)
	async def _stop(self, ctx: commands.Context):
		ctx.voice_state.songs.clear()

		if ctx.voice_state.is_playing:
			ctx.voice_state.voice.stop()
			await ctx.message.add_reaction('‚èπ')

	@commands.command(name=command[5][0], aliases=command[5][1:]) #ÌòÑÏû¨ ÏùåÏïÖ Ïä§ÌÇµ
	async def _skip(self, ctx: commands.Context, *, args: int = 1):
		if not ctx.voice_state.is_playing:
			return await ctx.send(embed=discord.Embed(title=':mute: ÌòÑÏû¨ Ïû¨ÏÉùÏ§ëÏù∏ ÏùåÏïÖÏù¥ ÏóÜÏäµÎãàÎã§.',colour = 0x2EFEF7))

		await ctx.message.add_reaction('‚è≠')

		if args != 1:
			ctx.voice_state.songs.select(args, ctx.voice_state.loop)

		ctx.voice_state.skip()
		'''	
		voter = ctx.message.author
		if voter == ctx.voice_state.current.requester:
			await ctx.message.add_reaction('‚è≠')
			ctx.voice_state.skip()
		elif voter.id not in ctx.voice_state.skip_votes:
			ctx.voice_state.skip_votes.add(voter.id)
			total_votes = len(ctx.voice_state.skip_votes)
			if total_votes >= 3:
				await ctx.message.add_reaction('‚è≠')
				ctx.voice_state.skip()
			else:
				await ctx.send('Skip vote added, currently at **{}/3**'.format(total_votes))
		else:
			await ctx.send('```Ïù¥ÎØ∏ Ìà¨ÌëúÌïòÏÖ®ÏäµÎãàÎã§.```')
		'''
	@commands.command(name=command[6][0], aliases=command[6][1:]) #Ïû¨ÏÉù Î™©Î°ù
	async def _queue(self, ctx: commands.Context, *, page: int = 1):

		if len(ctx.voice_state.songs) == 0:
			return await ctx.send(embed=discord.Embed(title=':mute: Ïû¨ÏÉùÎ™©Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.',colour = 0x2EFEF7))
		
		items_per_page = 10
		pages = math.ceil(len(ctx.voice_state.songs) / items_per_page)

		start = (page - 1) * items_per_page
		end = start + items_per_page

		queue = ''
		for i, song in enumerate(ctx.voice_state.songs[start:end], start=start):
			queue += '`{0}.` [**{1.source.title}**]({1.source.url})\n'.format(i + 1, song)

		if ctx.voice_state.loop:
			embed = discord.Embed(title = 'üîÅ  Now playing', description='**```fix\n{0.source.title}\n```**'.format(ctx.voice_state.current))
		else:
			embed = discord.Embed(title = 'Now playing', description='**```fix\n{0.source.title}\n```**'.format(ctx.voice_state.current))
		embed.add_field(name ='\u200B\n**{} tracks:**\n'.format(len(ctx.voice_state.songs)), value = f"\u200B\n{queue}")
		embed.set_thumbnail(url=ctx.voice_state.current.source.thumbnail)
		embed.set_footer(text='Viewing page {}/{}'.format(page, pages))
		await ctx.send(embed=embed)

	@commands.command(name=command[11][0], aliases=command[11][1:]) #ÏùåÏïÖ ÏÖîÌîå
	async def _shuffle(self, ctx: commands.Context):
		if len(ctx.voice_state.songs) == 0:
			return await ctx.send(embed=discord.Embed(title=':mute: Ïû¨ÏÉùÎ™©Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.',colour = 0x2EFEF7))

		ctx.voice_state.songs.shuffle()
		result = await ctx.send(embed=discord.Embed(title=':twisted_rightwards_arrows: ÏÖîÌîå ÏôÑÎ£å!',colour = 0x2EFEF7))
		await result.add_reaction('üîÄ')

	@commands.command(name=command[10][0], aliases=command[10][1:]) #ÏùåÏïÖ ÏÇ≠Ï†ú
	async def _remove(self, ctx: commands.Context, index: int):
		if len(ctx.voice_state.songs) == 0:
			return ctx.send(embed=discord.Embed(title=':mute: Ïû¨ÏÉùÎ™©Î°ùÏù¥ ÏóÜÏäµÎãàÎã§.',colour = 0x2EFEF7))
		
#		remove_result = '`{0}.` [**{1.source.title}**] ÏÇ≠Ï†ú ÏôÑÎ£å!\n'.format(index, ctx.voice_state.songs[index - 1])
		result = await ctx.send(embed=discord.Embed(title='`{0}.` [**{1.source.title}**] ÏÇ≠Ï†ú ÏôÑÎ£å!\n'.format(index, ctx.voice_state.songs[index - 1]),colour = 0x2EFEF7))
		ctx.voice_state.songs.remove(index - 1)
		await result.add_reaction('‚úÖ')


	@commands.command(name=command[14][0], aliases=command[14][1:]) #ÏùåÏïÖ Î∞òÎ≥µ
	async def _loop(self, ctx: commands.Context):
		if not ctx.voice_state.is_playing:
			return await ctx.send(embed=discord.Embed(title=':mute: ÌòÑÏû¨ Ïû¨ÏÉùÏ§ëÏù∏ ÏùåÏïÖÏù¥ ÏóÜÏäµÎãàÎã§.',colour = 0x2EFEF7))

		# Inverse boolean value to loop and unloop.
		ctx.voice_state.loop = not ctx.voice_state.loop
		if ctx.voice_state.loop :
			result = await ctx.send(embed=discord.Embed(title=':repeat: Î∞òÎ≥µÏû¨ÏÉùÏù¥ ÏÑ§Ï†ïÎêòÏóàÏäµÎãàÎã§!',colour = 0x2EFEF7))
		else:
			result = await ctx.send(embed=discord.Embed(title=':repeat_one: Î∞òÎ≥µÏû¨ÏÉùÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§!',colour = 0x2EFEF7))
		await result.add_reaction('üîÅ')

	@commands.command(name=command[2][0], aliases=command[2][1:]) #ÏùåÏïÖ Ïû¨ÏÉù
	async def _play(self, ctx: commands.Context, *, search: str):
		if not ctx.voice_state.voice:
			await ctx.invoke(self._summon)

		async with ctx.typing():
			try:
				source = await YTDLSource.create_source(self.bot, ctx, search, loop=self.bot.loop)
				if not source:
					return await ctx.send(f"ÎÖ∏Îûò Ïû¨ÏÉù/ÏòàÏïΩÏù¥ Ï∑®ÏÜå ÎêòÏóàÏäµÎãàÎã§.")
			except YTDLError as e:
				await ctx.send('ÏóêÎü¨Í∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§ : {}'.format(str(e)))
			else:
				song = Song(source)

				await ctx.channel.purge(limit=1)
				await ctx.voice_state.songs.put(song)
				await ctx.send(embed=discord.Embed(title=f':musical_note: Ïû¨ÏÉùÎ™©Î°ù Ï∂îÍ∞Ä : {str(source)}',colour = 0x2EFEF7))

#	@commands.command(name=command[13][0], aliases=command[13][1:]) #ÏßÄÏö∞Í∏∞
#	async def clear_channel_(self, ctx: commands.Context, *, msg: int = 1):
#		try:
#			msg = int(msg)
#		except:
#			await ctx.send(f"```ÏßÄÏö∞Í≥† Ïã∂ÏùÄ Ï§ÑÏàòÎäî [Ïà´Ïûê]Î°ú ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!```")
#		await ctx.channel.purge(limit = msg)

	@_summon.before_invoke
	@_play.before_invoke
	async def ensure_voice_state(self, ctx: commands.Context):
		if not ctx.author.voice or not ctx.author.voice.channel:
			raise commands.CommandError('ÏùåÏÑ±Ï±ÑÎÑêÏóê Ï†ëÏÜç ÌõÑ ÏÇ¨Ïö©Ìï¥Ï£ºÏã≠ÏãúÏò§.')

		if ctx.voice_client:
			if ctx.voice_client.channel != ctx.author.voice.channel:
				raise commands.CommandError('Î¥áÏù¥ Ïù¥ÎØ∏ ÏùåÏÑ±Ï±ÑÎÑêÏóê Ï†ëÏÜçÌï¥ ÏûàÏäµÎãàÎã§.')

#	@commands.command(name=command[12][0], aliases=command[12][1:])   #ÎèÑÏõÄÎßê
#	async def menu_(self, ctx):
#		command_list = ''
#		command_list += '!Ïù∏Ï§ë : Î¥áÏÉÅÌÉúÍ∞Ä ÏïàÏ¢ãÏùÑ Îïå Ïì∞ÏÑ∏Ïöî!'     #!
#		command_list += ','.join(command[0]) + '\n'     #!Îì§Ïñ¥Í∞ÄÏûê
#		command_list += ','.join(command[1]) + '\n'     #!ÎÇòÍ∞ÄÏûê
#		command_list += ','.join(command[2]) + ' [Í≤ÄÏÉâÏñ¥] or [url]\n'     #!Ïû¨ÏÉù
#		command_list += ','.join(command[3]) + '\n'     #!ÏùºÏãúÏ†ïÏßÄ
#		command_list += ','.join(command[4]) + '\n'     #!Îã§ÏãúÏû¨ÏÉù
#		command_list += ','.join(command[5]) + ' (Ïà´Ïûê)\n'     #!Ïä§ÌÇµ
#		command_list += ','.join(command[6]) + ' ÌòπÏùÄ [Î™ÖÎ†πÏñ¥] + [Ïà´Ïûê]\n'     #!Î™©Î°ù
#		command_list += ','.join(command[7]) + '\n'     #!ÌòÑÏû¨Ïû¨ÏÉù
#		command_list += ','.join(command[8]) + ' [Ïà´Ïûê 1~100]\n'     #!Î≥ºÎ•®
#		command_list += ','.join(command[9]) + '\n'     #!Ï†ïÏßÄ
#		command_list += ','.join(command[10]) + '\n'     #!ÏÇ≠Ï†ú
#		command_list += ','.join(command[11]) + '\n'     #!ÏÑûÍ∏∞
#		command_list += ','.join(command[14]) + '\n'     #!
#		command_list += ','.join(command[13]) + ' [Ïà´Ïûê]\n'     #!Í≤ΩÏ£º
#		embed = discord.Embed(
#				title = "----- Î™ÖÎ†πÏñ¥ -----",
#				description= '```' + command_list + '```',
#				color=0xff00ff
#				)
#		await ctx.send( embed=embed, tts=False)

	################ ÏùåÏÑ±ÌååÏùº ÏÉùÏÑ± ÌõÑ Ïû¨ÏÉù ################ 			
	@commands.command(name="==Ïù∏Ï§ë")
	async def playText_(self, ctx):
		#msg = ctx.message.content[len(ctx.invoked_with)+1:]
		#sayMessage = msg
		await MakeSound('ÎÆ§ÏßÅÎ¥áÏù¥ ÎßéÏù¥ ÏïÑÌååÏöî. Ïû†Ïãú ÌõÑ ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.', './say' + str(ctx.guild.id))
		await ctx.send("```ÎÆ§ÏßÅÎ¥áÏù¥ ÎßéÏù¥ ÏïÑÌååÏöî. Ïû†Ïãú ÌõÑ ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.```", tts=False)
		
		if not ctx.voice_state.voice:
			await ctx.invoke(self._summon)
			
		if ctx.voice_state.is_playing:
			ctx.voice_state.voice.stop()
		
		await PlaySound(ctx.voice_state.voice, './say' + str(ctx.guild.id) + '.wav')


		await ctx.voice_state.stop()
		del self.voice_states[ctx.guild.id]



#client = commands.Bot(command_prefix='==', help_command = None)
client = commands.Bot('', help_command = None)
client.add_cog(Music(client))

access_client_id = os.environ["client_id"]
access_client_secret = os.environ["client_secret"]

client_id = access_client_id
client_secret = access_client_secret

def create_soup(url, headers):
    res = requests.get(url, headers=headers)
    res.raise_for_status()
    soup = BeautifulSoup(res.text, 'lxml')
    return soup

@client.event
async def on_ready():
    print(f'Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ: {client.user.name}!')
    game = discord.Game("==Î™ÖÎ†πÏñ¥")
    await client.change_presence(status=discord.Status.online, activity=game)

@client.event 
async def on_command_error(ctx, error):
	if isinstance(error, CommandNotFound):
		return
	elif isinstance(error, discord.ext.commands.MissingRequiredArgument):
		return
	raise error

@client.command(pass_context = True, aliases=['==Î™ÖÎ†πÏñ¥'])
async def cmd_cmd_abc(ctx):
    await ctx.channel.purge(limit=1)
    emoji_list : list = ["üÖ∞Ô∏è", "1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£", "üö´"]

    embed = discord.Embed(title = "Ï∫¨Î£®Î¥á Î™ÖÎ†πÏñ¥ Î™©Î°ù", colour = 0x30e08b)
    embed.add_field(name = ':a: Ï†ÑÏ≤¥', value = 'Ï†ÑÏ≤¥ Î™ÖÎ†πÏñ¥ Î≥¥Í∏∞', inline = False)
    embed.add_field(name = ':one: ÏùºÎ∞ò', value = 'ÏùºÎ∞ò Î™ÖÎ†πÏñ¥ Î≥¥Í∏∞', inline = False)
    embed.add_field(name = ':two: TruckersMP', value = 'TruckersMP Í¥ÄÎ†® Î™ÖÎ†πÏñ¥ Î≥¥Í∏∞', inline = False)
    embed.add_field(name = ':three: ÏùåÏïÖ', value = 'ÏùåÏïÖ Ïû¨ÏÉù Í¥ÄÎ†® Î™ÖÎ†πÏñ¥ Î≥¥Í∏∞', inline = False)
    embed.add_field(name = ':no_entry_sign: Ï∑®ÏÜå', value = 'Ïã§Ìñâ Ï∑®ÏÜå', inline = False)
    cmd_message = await ctx.send(embed = embed)
    for emoji in emoji_list:
        await cmd_message.add_reaction(emoji)

    def reaction_check(reaction, user):
        return (reaction.message.id == cmd_message.id) and (user.id == ctx.author.id) and (str(reaction) in emoji_list)
    try:
        reaction, user = await client.wait_for('reaction_add', check = reaction_check, timeout = 10)
    except asyncio.TimeoutError:
        reaction = "üö´"

    for emoji in emoji_list:
#        await cmd_message.remove_reaction(emoji, client.user)
        await cmd_message.delete(delay = 0)

    await cmd_message.delete(delay = 10)
			
    if str(reaction) == "1Ô∏è‚É£":
        embed1 = discord.Embed(title = "Ï∫¨Î£®Î¥á Î™ÖÎ†πÏñ¥ Î™©Î°ù [ÏùºÎ∞ò Î™ÖÎ†πÏñ¥]", colour = 0x30e08b)
        embed1.add_field(name = '==ÏßÄÏö∞Í∏∞ <Ïà´Ïûê>', value = 'ÏµúÍ∑º 1~99Í∞úÏùò Î©îÏÑ∏ÏßÄÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.', inline = False)
        embed1.add_field(name = '==ÎÇ¥Ï†ïÎ≥¥', value = 'ÏûêÏã†Ïùò ÎîîÏä§ÏΩîÎìú Ï†ïÎ≥¥Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed1.add_field(name = '==Ïã§Í≤Ä', value = 'ÎÑ§Ïù¥Î≤ÑÏùò Í∏âÏÉÅÏäπ Í≤ÄÏÉâÏñ¥ TOP10ÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed1.add_field(name = '==ÎÇ†Ïî® <ÏßÄÏó≠>', value = '<ÏßÄÏó≠>Ïùò ÎÇ†Ïî®Î•º ÏïåÎ†§Ï§çÎãàÎã§.', inline = False)
        embed1.add_field(name = '==ÎßêÌï¥ <ÎÇ¥Ïö©>', value = '<ÎÇ¥Ïö©>ÏùÑ ÎßêÌï©ÎãàÎã§.', inline = False)
        embed1.add_field(name = '==Î≤àÏó≠ <Ïñ∏Ïñ¥> <ÎÇ¥Ïö©>', value = '<ÎÇ¥Ïö©>ÏùÑ Î≤àÏó≠Ìï©ÎãàÎã§.', inline = False)
        await ctx.channel.send(embed = embed1)
    elif str(reaction) == "2Ô∏è‚É£":
        embed2 = discord.Embed(title = "Ï∫¨Î£®Î¥á Î™ÖÎ†πÏñ¥ Î™©Î°ù [TruckersMP]", colour = 0x30e08b)
        embed2.add_field(name = '==TÏ†ïÎ≥¥, ==ts', value = 'TruckersMPÏùò  Ï†ïÎ≥¥Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed2.add_field(name = '==TÌîÑÎ°úÌïÑ <TMPID>, ==tp', value = 'Ìï¥Îãπ TMPID ÏïÑÏù¥ÎîîÎ•º Í∞ÄÏßÑ ÏÇ¨ÎûåÏùò ÌîÑÎ°úÌïÑÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed2.add_field(name = '==TÌä∏ÎûòÌîΩÏàúÏúÑ, ==ttr', value = 'TruckersMPÏùò Ìä∏ÎûòÌîΩ ÏàúÏúÑ TOP5Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        await ctx.channel.send(embed = embed2)
    elif str(reaction) == "3Ô∏è‚É£":
        embed3 = discord.Embed(title = "Ï∫¨Î£®Î¥á Î™ÖÎ†πÏñ¥ Î™©Î°ù [ÏùåÏïÖ Ïû¨ÏÉù]", colour = 0x30e08b)
        embed3.add_field(name = '==Îì§Ïñ¥ÏôÄ', value = 'Î¥áÏù¥ ÏùåÏÑ± ÌÜµÌôîÎ∞©Ïóê Îì§Ïñ¥ÏòµÎãàÎã§.', inline = False)
        embed3.add_field(name = '==ÎÇòÍ∞Ä', value = 'Î¥áÏù¥ ÏùåÏÑ± ÌÜµÌôîÎ∞©ÏóêÏÑú ÎÇòÍ∞ëÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Ïû¨ÏÉù', value = 'Î¥áÏù¥ ÏùåÏïÖÏùÑ Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==ÏùºÏãúÏ†ïÏßÄ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ ÏùºÏãú Ï†ïÏßÄÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Îã§ÏãúÏû¨ÏÉù', value = 'ÏùºÏãú Ï†ïÏßÄÌïú ÏùåÏïÖÏùÑ Îã§Ïãú Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Ïä§ÌÇµ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Ïä§ÌÇµÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Î™©Î°ù', value = 'Ïû¨ÏÉù Î™©Î°ùÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed3.add_field(name = '==ÌòÑÏû¨Ïû¨ÏÉù', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Î≥ºÎ•®', value = 'Î¥áÏùò Î≥ºÎ•®ÏùÑ Ï°∞Ï†àÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Ï†ïÏßÄ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Ï†ïÏßÄÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==ÏÇ≠Ï†ú <Ìä∏Îûô Î≤àÌò∏>', value = 'Ïû¨ÏÉù Î™©Î°ùÏóê ÏûàÎäî ÌäπÏ†ï ÏùåÏïÖÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.', inline = False)
        embed3.add_field(name = '==ÏÑûÍ∏∞', value = 'Ïû¨ÏÉù Î™©Î°ùÏùÑ ÏÑûÏäµÎãàÎã§.', inline = False)
        embed3.add_field(name = '==Î∞òÎ≥µ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Î∞òÎ≥µ Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        await ctx.channel.send(embed = embed3)
    elif str(reaction) == "üÖ∞Ô∏è":
        embed6 = discord.Embed(title = "Ï∫¨Î£®Î¥á Î™ÖÎ†πÏñ¥ Î™©Î°ù [Ï†ÑÏ≤¥ Î™ÖÎ†πÏñ¥]", colour = 0x30e08b)
        embed6.add_field(name = '==ÏßÄÏö∞Í∏∞ <Ïà´Ïûê>', value = 'ÏµúÍ∑º 1~99Í∞úÏùò Î©îÏÑ∏ÏßÄÎ•º ÏÇ≠Ï†úÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÎÇ¥Ï†ïÎ≥¥', value = 'ÏûêÏã†Ïùò ÎîîÏä§ÏΩîÎìú Ï†ïÎ≥¥Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Ïã§Í≤Ä', value = 'ÎÑ§Ïù¥Î≤ÑÏùò Í∏âÏÉÅÏäπ Í≤ÄÏÉâÏñ¥ TOP10ÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÎÇ†Ïî® <ÏßÄÏó≠>', value = '<ÏßÄÏó≠>Ïùò ÎÇ†Ïî®Î•º ÏïåÎ†§Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÎßêÌï¥ <ÎÇ¥Ïö©>', value = '<ÎÇ¥Ïö©>ÏùÑ ÎßêÌï©ÎãàÎã§.', inline = False)
        embed1.add_field(name = '==Î≤àÏó≠ <Ïñ∏Ïñ¥> <ÎÇ¥Ïö©>', value = '<ÎÇ¥Ïö©>ÏùÑ Î≤àÏó≠Ìï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==TÏ†ïÎ≥¥, ==ts', value = 'TruckersMPÏùò ÏÑúÎ≤Ñ Ï†ïÎ≥¥Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==TÌîÑÎ°úÌïÑ <TMPID>, ==tp', value = 'Ìï¥Îãπ TMPID ÏïÑÏù¥ÎîîÎ•º Í∞ÄÏßÑ ÏÇ¨ÎûåÏùò ÌîÑÎ°úÌïÑÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==TÌä∏ÎûòÌîΩÏàúÏúÑ, ==ttr', value = 'TruckersMPÏùò Ìä∏ÎûòÌîΩ ÏàúÏúÑ TOP5Î•º Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Îì§Ïñ¥ÏôÄ', value = 'Î¥áÏù¥ ÏùåÏÑ± ÌÜµÌôîÎ∞©Ïóê Îì§Ïñ¥ÏòµÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÎÇòÍ∞Ä', value = 'Î¥áÏù¥ ÏùåÏÑ± ÌÜµÌôîÎ∞©ÏóêÏÑú ÎÇòÍ∞ëÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Ïû¨ÏÉù', value = 'Î¥áÏù¥ ÏùåÏïÖÏùÑ Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÏùºÏãúÏ†ïÏßÄ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ ÏùºÏãú Ï†ïÏßÄÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Îã§ÏãúÏû¨ÏÉù', value = 'ÏùºÏãú Ï†ïÏßÄÌïú ÏùåÏïÖÏùÑ Îã§Ïãú Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Ïä§ÌÇµ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Ïä§ÌÇµÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Î™©Î°ù', value = 'Ïû¨ÏÉù Î™©Î°ùÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÌòÑÏû¨Ïû¨ÏÉù', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Î≥ºÎ•®', value = 'Î¥áÏùò Î≥ºÎ•®ÏùÑ Ï°∞Ï†àÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Ï†ïÏßÄ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Ï†ïÏßÄÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÏÇ≠Ï†ú <Ìä∏Îûô Î≤àÌò∏>', value = 'Ïû¨ÏÉù Î™©Î°ùÏóê ÏûàÎäî ÌäπÏ†ï ÏùåÏïÖÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.', inline = False)
        embed6.add_field(name = '==ÏÑûÍ∏∞', value = 'Ïû¨ÏÉù Î™©Î°ùÏùÑ ÏÑûÏäµÎãàÎã§.', inline = False)
        embed6.add_field(name = '==Î∞òÎ≥µ', value = 'ÌòÑÏû¨ Ïû¨ÏÉù Ï§ëÏù∏ ÏùåÏïÖÏùÑ Î∞òÎ≥µ Ïû¨ÏÉùÌï©ÎãàÎã§.', inline = False)
        await ctx.channel.send(embed = embed6)
    elif str(reaction) == "üö´":
        await cmd_message.delete(delay = 0)
    else:
        return False

@client.command(pass_context = True, aliases=['==ÏßÄÏö∞Í∏∞'])
@commands.has_permissions(administrator=True)
async def claer_clear_abc(ctx, amount):
    amount = int(amount)
    if amount < 100:
        await ctx.channel.purge(limit=amount)
        await ctx.channel.send(embed=discord.Embed(title=f":put_litter_in_its_place: {amount}Í∞úÏùò Ï±ÑÌåÖÏùÑ ÏÇ≠Ï†úÌñàÏñ¥Ïöî.",colour = 0x2EFEF7))
    else:
        await ctx.channel.purge(limit=1)
        await ctx.channel.send(embed=discord.Embed(title=f":no_entry_sign: Ïà´ÏûêÎ•º 99 Ïù¥ÌïòÎ°ú ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî.",colour = 0x2EFEF7)) 

@client.command(aliases=['==Ìïë'])
async def ping_ping_abc(ctx):
    await ctx.channel.send('ÌêÅ! `{}ms`'.format(round(client.latency * 1000)))

@client.command(pass_context = True, aliases=['==ÎÇ¥Ï†ïÎ≥¥'])
async def my_my_abc_profile(ctx):
    date = datetime.datetime.utcfromtimestamp(((int(ctx.author.id) >> 22) + 1420070400000) / 1000)
    embed = discord.Embed(title = ctx.author.display_name + "ÎãòÏùò Ï†ïÎ≥¥", colour = 0x2EFEF7)
    embed.add_field(name = 'ÏÇ¨Ïö©ÏûêÎ™Ö', value = ctx.author.name, inline = False)
    embed.add_field(name = 'Í∞ÄÏûÖÏùº', value = str(date.year) + "ÎÖÑ" + str(date.month) + "Ïõî" + str(date.day) + "Ïùº", inline = False)
    embed.add_field(name = 'ÏïÑÏù¥Îîî', value = ctx.author.id, inline = False)
    embed.set_thumbnail(url = ctx.author.avatar_url)
    await ctx.channel.send(embed = embed)

@client.command(pass_context = True, aliases=['==Ïπ¥Ìéò'])
async def cafe_cafe_abc(ctx):
    embed = discord.Embed(title = "KCTG Í≥µÏãù Ïπ¥Ìéò", colour = 0x2EFEF7)
    embed.add_field(name = 'https://cafe.naver.com/kctgofficial', value = "\n\u200b", inline = False)
    embed.set_thumbnail(url = "https://cdn.discordapp.com/attachments/740877681209507880/744451389396353106/KCTG_Wolf_1.png")
    await ctx.channel.send(embed = embed)

@client.command(pass_context = True, aliases=['==Ïã§Í≤Ä'])
async def search_search_abc_rank(ctx):
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Whale/2.8.105.22 Safari/537.36'}
    url = "https://datalab.naver.com/keyword/realtimeList.naver?where=main"
    soup = create_soup(url, headers)
    rank_list = soup.find("ul", attrs={"class":"ranking_list"})
    one = rank_list.find_all("span", attrs={"class":"item_title"})[0].get_text().strip().replace("1", "") #ÏàúÏÑúÎåÄÎ°ú Ïã§Í≤Ä 1~10ÏúÑ
    two = rank_list.find_all("span", attrs={"class":"item_title"})[1].get_text().strip().replace("2", "")
    three = rank_list.find_all("span", attrs={"class":"item_title"})[2].get_text().strip().replace("3", "")
    four = rank_list.find_all("span", attrs={"class":"item_title"})[3].get_text().strip().replace("4", "")
    five = rank_list.find_all("span", attrs={"class":"item_title"})[4].get_text().strip().replace("5", "")
    six = rank_list.find_all("span", attrs={"class":"item_title"})[5].get_text().strip().replace("6", "")
    seven = rank_list.find_all("span", attrs={"class":"item_title"})[6].get_text().strip().replace("7", "")
    eight = rank_list.find_all("span", attrs={"class":"item_title"})[7].get_text().strip().replace("8", "")
    nine = rank_list.find_all("span", attrs={"class":"item_title"})[8].get_text().strip().replace("9", "")
    ten = rank_list.find_all("span", attrs={"class":"item_title"})[9].get_text().strip().replace("10", "")
    time = soup.find("span", attrs={"class":"time_txt _title_hms"}).get_text() #ÌòÑÏû¨ ÏãúÍ∞Ñ
    await ctx.channel.send(f'‚Ö† ``{one}``\n‚Ö° ``{two}``\n‚Ö¢ ``{three}``\n‚Ö£ ``{four}``\n‚Ö§ ``{five}``\n‚Ö• ``{six}``\n‚Ö¶ ``{seven}``\n‚Öß ``{eight}``\n‚Ö® ``{nine}``\n‚Ö© ``{ten}``\n\n``Time[{time}]``')

@client.command(pass_context = True, aliases=['==ÎÇ†Ïî®'])
async def weather_weather_abc(ctx, arg1):
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Whale/2.8.105.22 Safari/537.36'}
    url = f"https://search.naver.com/search.naver?sm=tab_hty.top&where=nexearch&query={arg1}+ÎÇ†Ïî®&oquery=ÎÇ†Ïî®&tqi=U1NQ%2FsprvmsssUNA1MVssssssPN-224813"
    soup = create_soup(url, headers)
    rotate = soup.find("span", attrs={"class":"btn_select"}).get_text() #ÏßÄÏó≠
    cast = soup.find("p", attrs={"class":"cast_txt"}).get_text() #ÎßëÏùå, ÌùêÎ¶º Í∞ôÏùÄÍ±∞
    curr_temp = soup.find("p", attrs={"class":"info_temperature"}).get_text().replace("ÎèÑÏî®", "") #ÌòÑÏû¨ Ïò®ÎèÑ
    sen_temp = soup.find("span", attrs={"class":"sensible"}).get_text().replace("Ï≤¥Í∞êÏò®ÎèÑ", "Ï≤¥Í∞ê") #Ï≤¥Í∞ê Ïò®ÎèÑ
    min_temp = soup.find("span", attrs={"class":"min"}).get_text() #ÏµúÏ†Ä Ïò®ÎèÑ
    max_temp = soup.find("span", attrs={"class":"max"}).get_text() #ÏµúÍ≥† Ïò®ÎèÑ
    # Ïò§Ï†Ñ, Ïò§ÌõÑ Í∞ïÏàò ÌôïÎ•†
    morning_rain_rate = soup.find("span", attrs={"class":"point_time morning"}).get_text().strip() #Ïò§Ï†Ñ
    afternoon_rain_rate = soup.find("span", attrs={"class":"point_time afternoon"}).get_text().strip() #Ïò§ÌõÑ

    # ÎØ∏ÏÑ∏Î®ºÏßÄ, Ï¥àÎØ∏ÏÑ∏Î®ºÏßÄ
    dust = soup.find("dl", attrs={"class":"indicator"})
    pm10 = dust.find_all("dd")[0].get_text() #ÎØ∏ÏÑ∏Î®ºÏßÄ
    pm25 = dust.find_all("dd")[1].get_text() #Ï¥àÎØ∏ÏÑ∏Î®ºÏßÄ

    daylist = soup.find("ul", attrs={"class":"list_area _pageList"})
    tomorrow = daylist.find_all("li")[1]
    #ÎÇ¥Ïùº Ïò®ÎèÑ
    to_min_temp = tomorrow.find_all("span")[12].get_text() #ÏµúÏ†Ä
    to_max_temp = tomorrow.find_all("span")[14].get_text() #ÏµúÍ≥†
    #ÎÇ¥Ïùº Í∞ïÏàò
    to_morning_rain_rate = daylist.find_all("span", attrs={"class":"point_time morning"})[1].get_text().strip() #Ïò§Ï†Ñ
    to_afternoon_rain_rate = daylist.find_all("span", attrs={"class":"point_time afternoon"})[1].get_text().strip() #Ïò§ÌõÑ

    await ctx.channel.send((rotate) + f'\nÏò§ÎäòÏùò ÎÇ†Ïî® ``' + (cast) + f'``\n__Í∏∞Ïò®__ ``ÌòÑÏû¨ {curr_temp}({sen_temp}) ÏµúÏ†Ä {min_temp} ÏµúÍ≥† {max_temp}``\n__Í∞ïÏàò__ ``Ïò§Ï†Ñ {morning_rain_rate}`` ``Ïò§ÌõÑ {afternoon_rain_rate}``\n__ÎåÄÍ∏∞__ ``ÎØ∏ÏÑ∏Î®ºÏßÄ {pm10}`` ``Ï¥àÎØ∏ÏÑ∏Î®ºÏßÄ {pm25}``\n\nÎÇ¥ÏùºÏùò ÎÇ†Ïî®\n__Í∏∞Ïò®__ ``ÏµúÏ†Ä {to_min_temp}Àö`` ``ÏµúÍ≥† {to_max_temp}Àö``\n__Í∞ïÏàò__ ``Ïò§Ï†Ñ {to_morning_rain_rate}`` ``Ïò§ÌõÑ {to_afternoon_rain_rate}``')

@client.command(pass_context = True, aliases=['==ÎßêÌï¥'])
async def tell_tell_abc(ctx, *, arg):
    tell = str(arg)
    await ctx.channel.purge(limit=1)
    await ctx.channel.send(tell)

@client.command(pass_context = True, aliases=['==TÏ†ïÎ≥¥', '==TS', '==tÏ†ïÎ≥¥', '==ts'])
async def tmp_tmp_abc_server_status(ctx):
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Whale/2.8.105.22 Safari/537.36'}
    url = "https://stats.truckersmp.com/"
    soup = create_soup(url, headers)
    #ÌòÑÏû¨ Ï†ëÏÜçÏ§ëÏù∏ ÌîåÎ†àÏù¥Ïñ¥
    curr_status = soup.find("div", attrs={"class":"container-fluid"})
    sim1 = curr_status.find_all("div", attrs={"class":"server-count"})[0].get_text().strip()
    sim2 = curr_status.find_all("div", attrs={"class":"server-count"})[1].get_text().strip()
    sim_us = curr_status.find_all("div", attrs={"class":"server-count"})[2].get_text().strip()
    sim_sgp = curr_status.find_all("div", attrs={"class":"server-count"})[3].get_text().strip()
    arc = curr_status.find_all("div", attrs={"class":"server-count"})[4].get_text().strip()
    pro = curr_status.find_all("div", attrs={"class":"server-count"})[5].get_text().strip()
    pro_arc = curr_status.find_all("div", attrs={"class":"server-count"})[6].get_text().strip()
    #ÏÑúÎ≤Ñ Ïò®Ïò§ÌîÑ Ïó¨Î∂Ä
    sim1_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[0].get_text().strip().replace("LINE", "")
    sim2_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[1].get_text().strip().replace("LINE", "")
    sim_us_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[2].get_text().strip().replace("LINE", "")
    sim_sgp_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[3].get_text().strip().replace("LINE", "")
    arc_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[4].get_text().strip().replace("LINE", "")
    pro_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[5].get_text().strip().replace("LINE", "")
    pro_arc_sta = curr_status.find_all("div", attrs={"class":"server-status ONLINE"})[6].get_text().strip().replace("LINE", "")
    #ÏÑúÎ≤Ñ ÏãúÍ∞Ñ
    curr_game_time = soup.find("span", attrs={"id":"game_time"}).get_text().strip()

    embed = discord.Embed(title = "[ETS2] TruckersMP ÏÑúÎ≤Ñ ÌòÑÌô©", colour = 0x2EFEF7)
    embed.add_field(name = f'`[{sim1_sta}]` Simulation 1', value = f"{sim1}", inline = False)
    embed.add_field(name = f'`[{sim2_sta}]` Simulation 2', value = f"{sim2}", inline = False)
    embed.add_field(name = f'`[{sim_us_sta}]` [US] Simulation', value = f"{sim_us}", inline = False)
    embed.add_field(name = f'`[{sim_sgp_sta}]` [SGP] Simulation', value = f"{sim_sgp}", inline = False)
    embed.add_field(name = f'`[{arc_sta}]` Arcade', value = f"{arc}", inline = False)
    embed.add_field(name = f'`[{pro_sta}]` ProMods', value = f"{pro}", inline = False)
    embed.add_field(name = f'`[{pro_arc_sta}]` ProMods Arcade', value = f"{pro_arc}", inline = False)
    embed.set_footer(text=f"ÏÑúÎ≤Ñ ÏãúÍ∞Ñ: {curr_game_time}")
    await ctx.channel.send(embed = embed)

@client.command(pass_context = True, aliases=['==TÌä∏ÎûòÌîΩÏàúÏúÑ', '==TTR', '==tÌä∏ÎûòÌîΩÏàúÏúÑ', '==ttr'])
async def tmp_tmp_abc_traffic(ctx):
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Whale/2.8.105.22 Safari/537.36'}
    url = "https://traffic.krashnz.com/"
    soup = create_soup(url, headers)
    #Ïã§ÏãúÍ∞Ñ Ìä∏ÎûòÌîΩ ÏàúÏúÑ
    traffic_top = soup.find("ul", attrs={"class":"list-group mb-3"})
    rank1 = traffic_top.find_all("div")[1].get_text().strip()
    rank2 = traffic_top.find_all("div")[2].get_text().strip()
    rank3 = traffic_top.find_all("div")[3].get_text().strip()
    rank4 = traffic_top.find_all("div")[4].get_text().strip()
    rank5 = traffic_top.find_all("div")[5].get_text().strip()
    g_set = soup.find("div", attrs={"class":"row text-center mb-2"})
    g_player = g_set.find_all("span", attrs={"class":"stats-number"})[0].get_text().strip()
    g_time = g_set.find_all("span", attrs={"class":"stats-number"})[1].get_text().strip()

    embed = discord.Embed(title = "[ETS2] TruckersMP Ïã§ÏãúÍ∞Ñ Ìä∏ÎûòÌîΩ TOP5", colour = 0x2EFEF7)
    embed.add_field(name = f'{rank1}', value = "\n\u200b", inline = False)
    embed.add_field(name = f'{rank2}', value = "\n\u200b", inline = False)
    embed.add_field(name = f'{rank3}', value = "\n\u200b", inline = False)
    embed.add_field(name = f'{rank4}', value = "\n\u200b", inline = False)
    embed.add_field(name = f'{rank5}', value = f"\n{g_player} players tracked / {g_time} in-game time", inline = False)
    await ctx.channel.send(embed = embed)

@client.command(pass_context = True, aliases=['==TÌîÑÎ°úÌïÑ', '==TP', '==tÌîÑÎ°úÌïÑ', '==tp'])
async def tmp_tmp_abc_user_profile(ctx, arg):
    headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Whale/2.8.105.22 Safari/537.36'}
    url = f"https://truckersmp.com/user/{arg}"
    soup = create_soup(url, headers)
    #ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥
    user_status = soup.find("div", attrs={"class":"profile-bio"})
    name = user_status.find_all("span")[0].get_text().strip()
    check = user_status.find_all("strong")[0].get_text()
    if check == "Also known as":
        steam = user_status.find_all("span")[3].get_text().strip().replace("Steam ID:", "")
        birt = user_status.find_all("span")[5].get_text().strip().replace("Member since:", "")
        bans = user_status.find_all("span")[6].get_text().strip().replace("Active bans:", "")
    else:
        steam = user_status.find_all("span")[2].get_text().strip().replace("Steam ID:", "")
        birt = user_status.find_all("span")[4].get_text().strip().replace("Member since:", "")
        bans = user_status.find_all("span")[5].get_text().strip().replace("Active bans:", "")

    vtc_check = soup.find_all("h2", attrs={"class":"panel-title heading-sm pull-left"})[2].get_text()
    if vtc_check == " VTC":
        vtc_find = soup.find_all("div", attrs={"class":"panel panel-profile"})[2]
        vtc_name =  vtc_find.find("h5", attrs={"class":"text-center break-all"}).get_text().strip()
    else:
        vtc_name = "ÏóÜÏùå"

    #ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄ
    img = soup.find_all("div", attrs={"class": "col-md-3 md-margin-bottom-40"})[0]
    imgs = img.find("img", attrs={"class": "img-responsive profile-img margin-bottom-20 shadow-effect-1"})
    prof_image = imgs.get("src")

    embed = discord.Embed(title = f"[TruckersMP] {arg}'s ÌîÑÎ°úÌïÑ", colour = 0x2EFEF7)
    embed.add_field(name = 'Name', value = f"{name}", inline = False)
    embed.add_field(name = 'Steam ID', value = f"{steam}", inline = False)
    embed.add_field(name = 'Member since', value = f"{birt}", inline = False)
    embed.add_field(name = 'Active bans', value = f"{bans}", inline = False)
    embed.add_field(name = 'VTC', value = f"{vtc_name}", inline = False)
    embed.set_thumbnail(url=prof_image)
    await ctx.channel.send(embed = embed)
	
@client.command(aliases=['==Î≤àÏó≠'])
async def _translator_abc(ctx, arg, *, content):
    content = str(content)
    if arg[0] == 'Ìïú':
        langso = "Korean"
        so = "ko"
    elif arg[0] == 'ÏòÅ':
        langso = "English"
        so = "en"
    elif arg[0] == 'Ïùº':
        langso = "Japanese"
        so = "ja"
    elif arg[0] == 'Ï§ë':
        langso = "Chinese"
        so = "zh-CN"
    else:
        pass
    if arg[1] == 'Ìïú':
        langta = "Korean"
        ta = "ko"
    elif arg[1] == 'ÏòÅ':
        langta = "English"
        ta = "en"
    elif arg[1] == 'Ïùº':
        langta = "Japanese"
        ta = "ja"
    elif arg[1] == 'Ï§ë':
        langta = "Chinese"
        ta = "zh-CN"
    else:
        pass
    url = "https://openapi.naver.com/v1/papago/n2mt"
    #ÎùÑÏñ¥Ïì∞Í∏∞ : splitÏ≤òÎ¶¨ÌõÑ [1:]ÏùÑ forÎ¨∏ÏúºÎ°ú Î∂ôÏù∏Îã§.
    trsText = str(content)
    try:
        if len(trsText) == 1:
            await ctx.channel.send("Îã®Ïñ¥ ÌòπÏùÄ Î¨∏Ïû•ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.")
        else:
            trsText = trsText[0:]
            combineword = ""
            for word in trsText:
                combineword += "" + word
            sourcetext = combineword.strip()
            combineword = quote(sourcetext)
            dataParmas = f"source={so}&target={ta}&text=" + combineword
            request = Request(url)
            request.add_header("X-Naver-Client-Id", client_id)
            request.add_header("X-Naver-Client-Secret", client_secret)
            response = urlopen(request, data=dataParmas.encode("utf-8"))
            responsedCode = response.getcode()
            if (responsedCode == 200):
                response_body = response.read()
                # response_body -> byte string : decode to utf-8
                api_callResult = response_body.decode('utf-8')
                # JSON data will be printed as string type. So need to make it back to type JSON(like dictionary)
                api_callResult = json.loads(api_callResult)
                #Î≤àÏó≠ Í≤∞Í≥º
                translatedText = api_callResult['message']['result']["translatedText"]
                embed = discord.Embed(title=f"Î≤àÏó≠ ‚îÉ {langso} ‚Üí {langta}", description="", color=0x2e9fff)
                embed.add_field(name=f"{langso}", value=sourcetext, inline=False)
                embed.add_field(name=f"{langta}", value=translatedText, inline=False)
                embed.set_thumbnail(url="https://papago.naver.com/static/img/papago_og.png")
                embed.set_footer(text="API provided by Naver Open API",
                                 icon_url='https://papago.naver.com/static/img/papago_og.png')
                await ctx.channel.send(embed=embed)
            else:
                await ctx.channel.send("Error Code : " + responsedCode)
    except HTTPError as e:
        await ctx.channel.send("Î≤àÏó≠ Ïã§Ìå®. HTTPÏóêÎü¨ Î∞úÏÉù.")
	
access_token = os.environ["BOT_TOKEN"]
client.run(access_token)
